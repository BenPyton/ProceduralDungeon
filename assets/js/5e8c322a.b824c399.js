"use strict";(self.webpackChunkprocedural_dungeon_wiki=self.webpackChunkprocedural_dungeon_wiki||[]).push([[50594],{24099:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"api/index","title":"API References","description":"Documentation for classes, enums, structs, nodes, etc.","source":"@site/docs/api/index.md","sourceDirName":"api","slug":"/api/","permalink":"/ProceduralDungeon/api/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"API References","description":"Documentation for classes, enums, structs, nodes, etc.","sidebar_class_name":"hidden","pagination_prev":null,"pagination_next":null},"sidebar":"homeSidebar"}');var t=r(74848),i=r(28453);const d={title:"API References",description:"Documentation for classes, enums, structs, nodes, etc.",sidebar_class_name:"hidden",pagination_prev:null,pagination_next:null},o="Procedural Dungeon API",a={},l=[{value:"Classes",id:"classes",level:2},{value:"Structs",id:"structs",level:2},{value:"Enums",id:"enums",level:2}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"procedural-dungeon-api",children:"Procedural Dungeon API"})}),"\n",(0,t.jsx)(s.h2,{id:"classes",children:"Classes"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Name"}),(0,t.jsx)(s.th,{children:"Category"}),(0,t.jsx)(s.th,{children:"Exposed As"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/DeterministicRandomComponent/",children:"Deterministic Random Component"})}),(0,t.jsx)(s.td,{children:"ProceduralDungeon"}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsxs)(s.td,{children:["A simple component that adds a RandomStream to any actor placed in a room level.",(0,t.jsx)("br",{}),"It will uses the actor's guid (provided by a IRoomActorGuid interface) and the owning room's ID",(0,t.jsx)("br",{}),"to generate an initial seed unique for this actor but deterministic with the dungeon's seed."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/Door/",children:"Door"})}),(0,t.jsx)(s.td,{children:"Procedural"}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsxs)(s.td,{children:["Base class for all door actors in the dungeon.",(0,t.jsx)("br",{}),"Use this class even if you want to create a wall to place instead of a door (when the door is not connected to another room for example)."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/DoorType/",children:"Door Type"})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Data asset to define a door type.",(0,t.jsx)("br",{}),"A door type is used to define the size, offset, and color of a door bounds.",(0,t.jsx)("br",{}),"Doors with different types are not compatible with each others."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/DungeonBlueprintLibrary/",children:"Dungeon Blueprint Library"})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/DungeonGenerator/",children:"Dungeon Generator"})}),(0,t.jsx)(s.td,{children:"Procedural"}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsx)(s.td,{children:"This is the main actor of the plugin. The dungeon generator is responsible to generate dungeons and replicate them over the network."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/DungeonGeneratorBase/",children:"Dungeon Generator Base"})}),(0,t.jsx)(s.td,{children:"Procedural"}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsxs)(s.td,{children:["This is the main actor of the plugin. The dungeon generator is responsible to generate dungeons and replicate them over the network.",(0,t.jsx)("br",{}),"This base class is abstract. You need to override the ",(0,t.jsx)(s.code,{children:"CreateDungeon"})," function to write your own generation algorithm."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/DungeonGraph/",children:"Dungeon Graph"})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Holds the generated dungeon.",(0,t.jsx)("br",{}),"You can access the rooms using many functions."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/DungeonSaveInterface/",children:"Dungeon Save Interface"})}),(0,t.jsx)(s.td,{}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsx)(s.td,{children:"Give access to some serialization events to actors saved within a dungeon."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/ProceduralDungeonSettings/",children:"Procedural Dungeon Settings"})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{children:"Holds the plugin's settings."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/ReadOnlyRoom/",children:"Read Only Room"})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{children:"Allow access to only some members of Room instances during the generation process."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/ReplicableObject/",children:"Replicable Object"})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{}),(0,t.jsxs)(s.td,{children:["Base class for sub-objects that can be replicated.",(0,t.jsx)("br",{}),"This class is not blueprintable and should not be used directly in blueprints."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/Room/",children:"Room"})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"The room instances of the dungeon."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/RoomActorGuid/",children:"Room Actor Guid"})}),(0,t.jsx)(s.td,{}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsx)(s.td,{children:"Interface to access a custom Guid for actors saved within a dungeon."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/RoomConnection/",children:"Room Connection"})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"A DungeonGraph subobject that represents a connection between two rooms."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/RoomCustomData/",children:"Room Custom Data"})}),(0,t.jsx)(s.td,{}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsx)(s.td,{children:"Base class for user custom data embedded in room instances"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/RoomData/",children:"Room Data"})}),(0,t.jsx)(s.td,{}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsxs)(s.td,{children:["Static data shared by multiple room instances.",(0,t.jsx)("br",{}),"This data is used to define the room's properties and the room level to spawn."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/RoomLevel/",children:"Room Level"})}),(0,t.jsx)(s.td,{children:"Procedural"}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsxs)(s.td,{children:["Level script actor for a room instance.",(0,t.jsx)("br",{}),"This class is used to manage the room instance and its bounds."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/RoomObserverComponent/",children:"Room Observer Component"})}),(0,t.jsx)(s.td,{children:"ProceduralDungeon"}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Room Observer that auto-(un)bind itself when it enters/exits a dungeon room.",(0,t.jsx)("br",{}),"Could observe (be bound) multiple rooms at once if the actor overlaps multiple room.",(0,t.jsx)("br",{}),"This component ",(0,t.jsx)(s.strong,{children:"does"})," track its own Room, thus the actor can move between rooms (use StaticRoomObserverComponent instead if this behavior is not needed)."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/RoomVisibilityComponent/",children:"Room Visibility"})}),(0,t.jsx)(s.td,{children:"ProceduralDungeon"}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Actor component to manage the visibility of an actor in the dungeon.",(0,t.jsx)("br",{}),"Use this one if the actor is able to move room.",(0,t.jsx)("br",{}),"If the actor remains in the same room, use UStaticRoomVisibilityComponent instead."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/StaticRoomVisibilityComponent/",children:"Room Visibility (Static)"})}),(0,t.jsx)(s.td,{children:"ProceduralDungeon"}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Component to manage the visibility of an actor in the dungeon.",(0,t.jsx)("br",{}),"Use this one if the actor remains in the same room.",(0,t.jsx)("br",{}),"If the actor is able to move room, use URoomVisibilityComponent instead."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/RoomVisitor/",children:"Room Visitor"})}),(0,t.jsx)(s.td,{}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsx)(s.td,{children:"Interface which adds events to an actor (or a component) when the actor enters/exits a dungeon room."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/SimpleGuidComponent/",children:"Simple Guid Component"})}),(0,t.jsx)(s.td,{children:"ProceduralDungeon"}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsxs)(s.td,{children:["A simple guid component that will retrieve the Editor's ActorGuid",(0,t.jsx)("br",{}),"to save/load it in packaged games.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),":::warning",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),"This component will work only on placed actor, not actors spawned during runtime!!!",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),":::"]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/StaticRoomObserverComponent/",children:"Static Room Observer Component"})}),(0,t.jsx)(s.td,{children:"ProceduralDungeon"}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Room Observer that auto-(un)bind itself at BeginPlay and EndPlay.",(0,t.jsx)("br",{}),"This component will bind to the level it belongs to. So it needs to be placed directly in the Room map.",(0,t.jsx)("br",{}),"This component does ",(0,t.jsx)(s.strong,{children:"not"})," track its own Room, thus the actor should not move between rooms (use RoomObserverComponent instead)."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/TriggerDoor/",children:"Trigger Door"})}),(0,t.jsx)(s.td,{}),(0,t.jsxs)(s.td,{children:["Blueprint\xa0Base\xa0Class",(0,t.jsx)("br",{}),"Variable\xa0Type"]}),(0,t.jsxs)(s.td,{children:["Door that opens when an actor enters the trigger box.",(0,t.jsx)("br",{}),"You can customize which actors can open the door by overriding the IsValidActor function."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Classes/TriggerType/",children:"Trigger Type"})}),(0,t.jsx)(s.td,{children:"Custom"}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Trigger box that manages detection of actors entering and exiting the trigger.",(0,t.jsx)("br",{}),"Can execute gameplay logic at regular intervals, with an optional delay before activation.",(0,t.jsx)("br",{}),"You can customize the actor type that can activate the trigger by setting the ActorType property."]})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"structs",children:"Structs"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Name"}),(0,t.jsx)(s.th,{children:"Exposed As"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Structs/BoundsParams/",children:"Bounds Params"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"Holds the settings for the dungeon limits."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Structs/DoorDef/",children:"Door Def"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Structure that defines a door.",(0,t.jsx)("br",{}),"A door is defined by its position, its direction, and its type."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Structs/DungeonSaveData/",children:"Dungeon Save Data"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"Holds the data for saving a dungeon state"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Structs/VoxelBoundsConnection/",children:"Room Bounds Connection"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"Base class for the different connection types."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Structs/RoomCandidate/",children:"Room Candidate"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsxs)(s.td,{children:["Describe a potential room to be added to the dungeon.",(0,t.jsx)("br",{}),"Mainly used by FilterAndSortRooms function."]})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"enums",children:"Enums"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Name"}),(0,t.jsx)(s.th,{children:"Exposed As"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Enums/EDoorDirection/",children:"Door Direction"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"The different directions a door can face."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Enums/EGenerationType/",children:"Generation Type"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"The different types of generation algorithms."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Enums/EVoxelBoundsConnectionType/",children:"Room Bounds Connection Type"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Enums/EVisibilityMode/",children:"Room Visibility"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"Visibility mode for Room Visibilty Components."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"C++"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"/ProceduralDungeon/api/Enums/ESeedType/",children:"Seed Type"})}),(0,t.jsx)(s.td,{children:"Variable\xa0Type"}),(0,t.jsx)(s.td,{children:"The different types of seed update at each generation."})]})]})]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>d,x:()=>o});var n=r(96540);const t={},i=n.createContext(t);function d(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);