"use strict";(self.webpackChunkprocedural_dungeon_wiki=self.webpackChunkprocedural_dungeon_wiki||[]).push([[8856],{61335:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var t=o(74848),r=o(28453);const a={pagination_prev:null,pagination_next:null},i="Custom Create Dungeon Function",s={id:"guides/Advanced-Features/Custom-Create-Dungeon",title:"Custom Create Dungeon Function",description:"As of now, overriding the Create Dungeon function is only available in C++ because I didn't found out in blueprint how to prevent overriding functions in child classes while allowing them in parent class.",source:"@site/docs/guides/Advanced-Features/Custom-Create-Dungeon.md",sourceDirName:"guides/Advanced-Features",slug:"/guides/Advanced-Features/Custom-Create-Dungeon",permalink:"/ProceduralDungeon/guides/Advanced-Features/Custom-Create-Dungeon",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{pagination_prev:null,pagination_next:null},sidebar:"homeSidebar"},d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"The <code>Dungeon Generator Base</code> class",id:"the-dungeon-generator-base-class",level:2}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsxs)(n.h1,{id:"custom-create-dungeon-function",children:["Custom ",(0,t.jsx)(n.code,{children:"Create Dungeon"})," Function"]})}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsxs)(n.p,{children:["As of now, overriding the ",(0,t.jsx)(n.code,{children:"Create Dungeon"})," function is only available in C++ because I didn't found out in blueprint how to prevent overriding functions in child classes while allowing them in parent class."]}),(0,t.jsxs)(n.p,{children:["If you know how to do that, please let me know on ",(0,t.jsx)(n.a,{href:"https://github.com/BenPyton/ProceduralDungeon/issues",children:(0,t.jsx)(n.strong,{children:"Github"})})," or ",(0,t.jsx)(n.a,{href:"https://discord.gg/YE2dPda2CC",children:(0,t.jsx)(n.strong,{children:"Discord"})}),"!"]})]}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:["The provided ",(0,t.jsx)(n.code,{children:"Dungeon Generator"})," class in the plugin has a basic default generation algorithm.",(0,t.jsx)(n.br,{}),"\n","Its behavior is to create a first room and then add new rooms to existing doors."]}),"\n",(0,t.jsxs)(n.p,{children:["See the ",(0,t.jsx)(n.code,{children:"Create Dungeon"})," function in the diagram below:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:o(13282).A+""})}),"\n",(0,t.jsxs)(n.p,{children:["If you are not satisfied with this default behavior, you can write your own ",(0,t.jsx)(n.code,{children:"Create Dungeon"})," function while keeping the core features of the generator."]}),"\n",(0,t.jsxs)(n.h2,{id:"the-dungeon-generator-base-class",children:["The ",(0,t.jsx)(n.code,{children:"Dungeon Generator Base"})," class"]}),"\n",(0,t.jsxs)(n.p,{children:["To write your own custom ",(0,t.jsx)(n.code,{children:"Create Dungeon"}),", you'll need to create a new class deriving from ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Dungeon Generator Base"})}),".",(0,t.jsx)(n.br,{}),"\n","This class has the core features of a dungeon generator: the state machine to load/unload the level instances (shown in the diagram above), the network replication, the room culling system, etc."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["You ",(0,t.jsx)(n.em,{children:"can"})," derive from the ",(0,t.jsx)(n.code,{children:"Dungeon Generator"})," class and override the ",(0,t.jsx)(n.code,{children:"Create Dungeon"})," function, but I would strongly discourage that as it will embed some generator's settings and overridable functions that you will certainly not using anymore."]})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["You can look into the ",(0,t.jsx)(n.code,{children:"Dungeon Generator"})," class as an example to help you writing your own ",(0,t.jsx)(n.code,{children:"Create Function"}),"."]})}),"\n",(0,t.jsx)(n.p,{children:"Below is a template to start your class.\r\nYou can then add any variables and functions you need for your generation."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="MyCustomDungeonGenerator.h"',children:"UCLASS()\r\nclass AMyCustomDungeonGenerator : public ADungeonGeneratorBase\r\n{\r\n    GENERATED_BODY()\r\n\r\nprotected:\r\n\t//~ Begin ADungeonGeneratorBase Interface\r\n\tvirtual bool CreateDungeon_Implementation() override;\r\n\t//~ End ADungeonGeneratorBase Interface\r\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="MyCustomDungeonGenerator.cpp"',children:"URoomData* AMyCustomDungeonGenerator::CreateDungeon_Implementation()\r\n{\r\n    // Must be called whenever you start a new generation.\r\n    // It will call the `Generation Init` event to allow resetting variables used for the generation.\r\n    StartNewDungeon();\r\n\r\n    // ... Do your generation logic here ...\r\n    // Here the important functions to create and place a new room in the dungeon:\r\n    {\r\n        // Create a new room instance from a room data\r\n        URoom* NewRoom = CreateRoomInstance(RoomData);\r\n\r\n        // Will attempt to place the room in a way to connect the NewRoom's door at specified index to the target door.\r\n        // The GetWorld() is used to also check is the room is colliding with actors in the world (when the bUseWorldCollisionCheck is true).\r\n        if (!TryPlaceRoom(NewRoom, NewRoomDoorIndex, TargetDoor, GetWorld())\r\n        {\r\n            // The room could not be placed.\r\n            NewRoom = nullptr;\r\n        }\r\n\r\n        // Will actually adds the room into the dungeon and connects the provided doors if possible.\r\n        // This function will call `OnRoomAdded` and return true if the room has been successfully added to the dungeon.\r\n        // You can pass an empty array as `DoorsToConnect` to try connecting all the doors.\r\n        if (!AddRoomToDungeon(NewRoom, /*DoorsToConnect = */TArray<int>{NewRoomDoorIndex}, /*bFailIfNotConnected = */true))\r\n        {\r\n            // The room was not added to the dungeon, because it was invalid (nullptr) or not connected.\r\n            OnFailedToAddRoom(ParentRoomData, TargetDoor);\r\n        }\r\n    }\r\n    // ...\r\n\r\n    // Must be called when the dungeon has finished the generation.\r\n    // Will initialize the room instances and call the `Initialize Dungeon` event.\r\n    FinalizeDungeon();\r\n\r\n    // You should return true when the dungeon is generated properly.\r\n    // If returning false, the dungeon will be erased and an error will be displayed.\r\n    return true;\r\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},13282:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/Flowchart_Dark_v4-a1e2ae2c93738a9955d422e88f457a71.svg"},28453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>s});var t=o(96540);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);